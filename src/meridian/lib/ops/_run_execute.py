"""Run execution helpers shared by sync and async run handlers."""

from __future__ import annotations

import argparse
import asyncio
import json
import os
import subprocess
import sys
import time
from collections.abc import Sequence
from pathlib import Path
from typing import Any, Protocol, cast

import structlog

from meridian.lib.domain import Run
from meridian.lib.exec.spawn import execute_with_finalization
from meridian.lib.exec.terminal import TerminalEventFilter, resolve_visible_categories
from meridian.lib.harness.adapter import PermissionResolver
from meridian.lib.ops._runtime import (
    SPACE_REQUIRED_ERROR,
    OperationRuntime,
    build_runtime,
    resolve_space_id,
)
from meridian.lib.safety.budget import Budget
from meridian.lib.safety.permissions import (
    PermissionConfig,
    build_permission_resolver,
    parse_permission_tier,
)
from meridian.lib.safety.redaction import SecretSpec, secrets_env_overrides
from meridian.lib.state import run_store
from meridian.lib.state.paths import resolve_run_log_dir, resolve_space_dir
from meridian.lib.types import ModelId, RunId, SpaceId

from ._run_models import RunActionOutput, RunCreateInput
from ._run_query import _read_run_row

_BACKGROUND_TASKS: set[asyncio.Task[None]] = set()
logger = structlog.get_logger(__name__)
_BACKGROUND_SUBMIT_MESSAGE = "Background run submitted."
_BACKGROUND_PID_FILENAME = "background.pid"
_BACKGROUND_STDOUT_FILENAME = "background-launcher.stdout.log"
_BACKGROUND_STDERR_FILENAME = "background-launcher.stderr.log"
_SECRET_ENV_PREFIX = "MERIDIAN_SECRET_"


class _PreparedCreateLike(Protocol):
    model: str
    harness_id: str
    warning: str | None
    composed_prompt: str
    skills: tuple[str, ...]
    reference_files: tuple[str, ...]
    template_vars: dict[str, str]
    report_path: str
    mcp_tools: tuple[str, ...]
    agent_name: str | None
    cli_command: tuple[str, ...]
    permission_config: PermissionConfig
    permission_resolver: PermissionResolver
    allowed_tools: tuple[str, ...]
    budget: Budget | None
    guardrails: tuple[str, ...]
    secrets: tuple[SecretSpec, ...]
    continue_harness_session_id: str | None
    continue_fork: bool


def _read_non_negative_int_env(name: str, default: int) -> int:
    raw = os.getenv(name, "").strip()
    if not raw:
        return default
    try:
        value = int(raw)
    except ValueError as exc:
        raise ValueError(f"{name} must be an integer.") from exc
    if value < 0:
        raise ValueError(f"{name} must be >= 0.")
    return value


def _depth_limits(max_depth: int) -> tuple[int, int]:
    current_depth = _read_non_negative_int_env("MERIDIAN_DEPTH", 0)
    if max_depth < 0:
        raise ValueError("max_depth must be >= 0.")
    return current_depth, max_depth


def _emit_subrun_event(payload: dict[str, Any]) -> None:
    if _read_non_negative_int_env("MERIDIAN_DEPTH", 0) <= 0:
        return
    event_payload = dict(payload)
    event_payload["v"] = 1
    parent_run_id = os.getenv("MERIDIAN_PARENT_RUN_ID", "").strip()
    event_payload["parent"] = parent_run_id or None
    event_payload["ts"] = time.time()
    print(json.dumps(event_payload, separators=(",", ":")), file=sys.stdout, flush=True)


def _depth_exceeded_output(current_depth: int, max_depth: int) -> RunActionOutput:
    return RunActionOutput(
        command="run.spawn",
        status="failed",
        message=f"Max agent depth ({max_depth}) reached. Complete this task directly.",
        error="max_depth_exceeded",
        current_depth=current_depth,
        max_depth=max_depth,
    )


def _run_child_env(
    space_id: str | None,
    secrets: tuple[SecretSpec, ...],
    parent_run_id: str | None = None,
) -> dict[str, str]:
    # Preserve Meridian run context across nesting without forwarding unrelated
    # parent process environment variables.
    child_env = {key: value for key, value in os.environ.items() if key.startswith("MERIDIAN_")}
    current_depth = _read_non_negative_int_env("MERIDIAN_DEPTH", 0)
    child_env["MERIDIAN_DEPTH"] = str(current_depth + 1)
    if space_id is not None:
        child_env["MERIDIAN_SPACE_ID"] = space_id
    if parent_run_id is None:
        child_env.pop("MERIDIAN_PARENT_RUN_ID", None)
    else:
        normalized_parent = parent_run_id.strip()
        if normalized_parent:
            child_env["MERIDIAN_PARENT_RUN_ID"] = normalized_parent
        else:
            child_env.pop("MERIDIAN_PARENT_RUN_ID", None)
    child_env.update(secrets_env_overrides(secrets))
    return child_env


def _secrets_from_env() -> tuple[SecretSpec, ...]:
    parsed: list[SecretSpec] = []
    for key in sorted(os.environ):
        if not key.startswith(_SECRET_ENV_PREFIX):
            continue
        secret_key = key[len(_SECRET_ENV_PREFIX) :].strip()
        if not secret_key:
            continue
        parsed.append(SecretSpec(key=secret_key, value=os.environ[key]))
    return tuple(parsed)


def _resolve_chat_id() -> str:
    chat_id = os.getenv("MERIDIAN_CHAT_ID", "").strip()
    if chat_id:
        return chat_id
    return "c0"


def _resolve_space(repo_root: Path, payload_space: str | None) -> tuple[SpaceId, Path]:
    resolved = resolve_space_id(payload_space)
    if resolved is None:
        raise ValueError(SPACE_REQUIRED_ERROR)
    return resolved, resolve_space_dir(repo_root, resolved)


def _space_spend_usd(space_dir: Path) -> float:
    total = 0.0
    for run in run_store.list_runs(space_dir):
        if run.total_cost_usd is not None:
            total += run.total_cost_usd
    return total


def _stdout_is_tty() -> bool:
    try:
        return bool(sys.stdout.isatty())
    except Exception:
        return False


async def _execute_existing_run(
    *,
    run_id: RunId,
    repo_root: Path,
    timeout_secs: float | None,
    skills: tuple[str, ...],
    agent_name: str | None,
    mcp_tools: tuple[str, ...],
    permission_config: PermissionConfig,
    allowed_tools: tuple[str, ...] = (),
    cli_permission_override: bool = False,
    budget: Budget | None = None,
    guardrails: tuple[str, ...] = (),
    secrets: tuple[SecretSpec, ...] = (),
    continue_harness_session_id: str | None = None,
    continue_fork: bool = False,
    space_id_hint: str | None = None,
) -> int:
    runtime = build_runtime(str(repo_root))
    space_id_text = (space_id_hint or os.getenv("MERIDIAN_SPACE_ID", "")).strip()
    if not space_id_text:
        logger.error("Missing space ID for run execution.", run_id=str(run_id))
        return 1

    space_dir = resolve_space_dir(repo_root, space_id_text)
    run_record = run_store.get_run(space_dir, run_id)
    if run_record is None or run_record.model is None or run_record.prompt is None:
        logger.error("Run not found for background execution.", run_id=str(run_id))
        return 1
    run = Run(
        run_id=RunId(run_record.id),
        prompt=run_record.prompt,
        model=ModelId(run_record.model),
        status="running",
        space_id=SpaceId(space_id_text),
    )

    resolver = build_permission_resolver(
        allowed_tools=allowed_tools,
        permission_config=permission_config,
        cli_permission_override=cli_permission_override,
    )

    return await execute_with_finalization(
        run,
        repo_root=runtime.repo_root,
        space_dir=space_dir,
        artifacts=runtime.artifacts,
        registry=runtime.harness_registry,
        permission_resolver=resolver,
        permission_config=permission_config,
        cwd=runtime.repo_root,
        timeout_seconds=timeout_secs,
        kill_grace_seconds=runtime.config.kill_grace_seconds,
        skills=skills,
        agent=agent_name,
        mcp_tools=mcp_tools,
        env_overrides=_run_child_env(
            space_id_text,
            secrets,
            str(run.run_id),
        ),
        budget=budget,
        space_spent_usd=_space_spend_usd(space_dir),
        max_retries=runtime.config.max_retries,
        retry_backoff_seconds=runtime.config.retry_backoff_seconds,
        guardrails=tuple(Path(item) for item in guardrails),
        guardrail_timeout_seconds=runtime.config.guardrail_timeout_seconds,
        secrets=secrets,
        continue_harness_session_id=continue_harness_session_id,
        continue_fork=continue_fork,
    )


def _build_background_worker_command(
    *,
    run_id: str,
    repo_root: Path,
    space_id: str | None,
    timeout_secs: float | None,
    skills: tuple[str, ...],
    agent_name: str | None,
    mcp_tools: tuple[str, ...],
    permission_config: PermissionConfig,
    allowed_tools: tuple[str, ...],
    cli_permission_override: bool,
    budget: Budget | None,
    guardrails: tuple[str, ...],
    continue_harness_session_id: str | None,
    continue_fork: bool,
) -> tuple[str, ...]:
    command: list[str] = [
        sys.executable,
        "-m",
        "meridian.lib.ops._run_execute",
        "--run-id",
        run_id,
        "--repo-root",
        repo_root.as_posix(),
        "--permission-tier",
        permission_config.tier.value,
    ]
    if space_id is not None:
        command.extend(["--space-id", space_id])
    if timeout_secs is not None:
        command.extend(["--timeout-secs", str(timeout_secs)])
    if permission_config.unsafe:
        command.append("--unsafe")
    if budget is not None:
        if budget.per_run_usd is not None:
            command.extend(["--budget-per-run-usd", str(budget.per_run_usd)])
        if budget.per_space_usd is not None:
            command.extend(
                ["--budget-per-space-usd", str(budget.per_space_usd)]
            )
    if agent_name is not None:
        command.extend(["--agent", agent_name])
    for skill in skills:
        command.extend(["--skill", skill])
    for tool in mcp_tools:
        command.extend(["--mcp-tool", tool])
    for tool in allowed_tools:
        command.extend(["--allowed-tool", tool])
    if cli_permission_override:
        command.append("--cli-permission-override")
    for guardrail in guardrails:
        command.extend(["--guardrail", guardrail])
    if continue_harness_session_id is not None and continue_harness_session_id.strip():
        command.extend(["--continue-harness-session-id", continue_harness_session_id.strip()])
    if continue_fork:
        command.append("--continue-fork")
    return tuple(command)


def _execute_run_background(
    *,
    payload: RunCreateInput,
    prepared: _PreparedCreateLike,
    runtime: OperationRuntime,
) -> RunActionOutput:
    if payload.stream:
        logger.warning("--stream is ignored with --background; output goes to run log files.")
    space_id, space_dir = _resolve_space(runtime.repo_root, payload.space)
    run_id = run_store.start_run(
        space_dir,
        chat_id=_resolve_chat_id(),
        model=prepared.model,
        agent=prepared.agent_name or "",
        harness=prepared.harness_id,
        prompt=prepared.composed_prompt,
        harness_session_id=prepared.continue_harness_session_id,
    )
    run = Run(
        run_id=RunId(run_id),
        prompt=prepared.composed_prompt,
        model=ModelId(prepared.model),
        status="running",
        space_id=space_id,
    )
    run_id_text = str(run.run_id)
    space_id_str = str(space_id)

    current_depth = _read_non_negative_int_env("MERIDIAN_DEPTH", 0)
    run_start_event: dict[str, Any] = {
        "t": "meridian.run.start",
        "id": run_id_text,
        "model": prepared.model,
        "d": current_depth,
    }
    if prepared.agent_name is not None:
        run_start_event["agent"] = prepared.agent_name
    _emit_subrun_event(run_start_event)

    launch_command = _build_background_worker_command(
        run_id=run_id_text,
        repo_root=runtime.repo_root,
        space_id=space_id_str,
        timeout_secs=payload.timeout_secs,
        skills=prepared.skills,
        agent_name=prepared.agent_name,
        mcp_tools=prepared.mcp_tools,
        permission_config=prepared.permission_config,
        allowed_tools=prepared.allowed_tools,
        cli_permission_override=payload.permission_tier is not None,
        budget=prepared.budget,
        guardrails=prepared.guardrails,
        continue_harness_session_id=prepared.continue_harness_session_id,
        continue_fork=prepared.continue_fork,
    )
    log_dir = resolve_run_log_dir(runtime.repo_root, run.run_id, run.space_id)
    log_dir.mkdir(parents=True, exist_ok=True)
    stdout_path = log_dir / _BACKGROUND_STDOUT_FILENAME
    stderr_path = log_dir / _BACKGROUND_STDERR_FILENAME

    launch_env = dict(os.environ)
    launch_env.update(secrets_env_overrides(prepared.secrets))
    try:
        with (
            stdout_path.open("ab") as stdout_handle,
            stderr_path.open("ab") as stderr_handle,
        ):
            process = subprocess.Popen(
                launch_command,
                cwd=runtime.repo_root,
                env=launch_env,
                stdin=subprocess.DEVNULL,
                stdout=stdout_handle,
                stderr=stderr_handle,
                start_new_session=True,
            )
    except OSError as exc:
        run_store.finalize_run(
            space_dir,
            run.run_id,
            status="failed",
            exit_code=1,
            error=str(exc),
        )
        logger.exception(
            "Failed to launch background run worker.",
            run_id=run_id_text,
            command=list(launch_command),
        )
        return RunActionOutput(
            command="run.spawn",
            status="failed",
            run_id=run_id_text,
            message=f"Failed to launch background run: {exc}",
            error="background_launch_failed",
            model=prepared.model,
            harness_id=prepared.harness_id,
            warning=prepared.warning,
            agent=prepared.agent_name,
            skills=prepared.skills,
            reference_files=prepared.reference_files,
            template_vars=prepared.template_vars,
            report_path=prepared.report_path,
            cli_command=prepared.cli_command,
            exit_code=1,
        )

    (log_dir / _BACKGROUND_PID_FILENAME).write_text(f"{process.pid}\n", encoding="utf-8")
    # The Popen object goes out of scope without wait(). This is intentional:
    # the child runs in its own session (start_new_session=True) and is
    # re-parented to init/systemd. We only need the PID for diagnostics.
    return RunActionOutput(
        command="run.spawn",
        status="running",
        run_id=run_id_text,
        message=_BACKGROUND_SUBMIT_MESSAGE,
        model=prepared.model,
        harness_id=prepared.harness_id,
        warning=prepared.warning,
        agent=prepared.agent_name,
        skills=prepared.skills,
        reference_files=prepared.reference_files,
        template_vars=prepared.template_vars,
        report_path=prepared.report_path,
        cli_command=prepared.cli_command,
        background=True,
    )


def _execute_run_blocking(
    *,
    payload: RunCreateInput,
    prepared: _PreparedCreateLike,
    runtime: OperationRuntime,
) -> RunActionOutput:
    space_id, space_dir = _resolve_space(runtime.repo_root, payload.space)
    run_id = run_store.start_run(
        space_dir,
        chat_id=_resolve_chat_id(),
        model=prepared.model,
        agent=prepared.agent_name or "",
        harness=prepared.harness_id,
        prompt=prepared.composed_prompt,
        harness_session_id=prepared.continue_harness_session_id,
    )
    run = Run(
        run_id=RunId(run_id),
        prompt=prepared.composed_prompt,
        model=ModelId(prepared.model),
        status="running",
        space_id=space_id,
    )
    current_depth = _read_non_negative_int_env("MERIDIAN_DEPTH", 0)
    run_start_event: dict[str, Any] = {
        "t": "meridian.run.start",
        "id": str(run.run_id),
        "model": prepared.model,
        "d": current_depth,
    }
    if prepared.agent_name is not None:
        run_start_event["agent"] = prepared.agent_name
    _emit_subrun_event(run_start_event)

    started = time.monotonic()
    space_id_str = str(space_id)
    event_observer = None
    stdout_is_tty = _stdout_is_tty()
    stream_stdout_to_terminal = payload.stream or not stdout_is_tty
    if not payload.stream and stdout_is_tty:
        event_filter = TerminalEventFilter(
            visible_categories=resolve_visible_categories(
                verbose=payload.verbose,
                quiet=payload.quiet,
                config=runtime.config.output,
            ),
            root_depth=_read_non_negative_int_env("MERIDIAN_DEPTH", 0),
        )
        event_observer = event_filter.observe

    exit_code = asyncio.run(
        execute_with_finalization(
            run,
            repo_root=runtime.repo_root,
            space_dir=space_dir,
            artifacts=runtime.artifacts,
            registry=runtime.harness_registry,
            permission_resolver=prepared.permission_resolver,
            permission_config=prepared.permission_config,
            cwd=runtime.repo_root,
            timeout_seconds=payload.timeout_secs,
            kill_grace_seconds=runtime.config.kill_grace_seconds,
            skills=prepared.skills,
            agent=prepared.agent_name,
            mcp_tools=prepared.mcp_tools,
            env_overrides=_run_child_env(
                space_id_str,
                prepared.secrets,
                str(run.run_id),
            ),
            budget=prepared.budget,
            space_spent_usd=_space_spend_usd(space_dir),
            max_retries=runtime.config.max_retries,
            retry_backoff_seconds=runtime.config.retry_backoff_seconds,
            guardrails=tuple(Path(item) for item in prepared.guardrails),
            guardrail_timeout_seconds=runtime.config.guardrail_timeout_seconds,
            secrets=prepared.secrets,
            continue_harness_session_id=prepared.continue_harness_session_id,
            continue_fork=prepared.continue_fork,
            event_observer=event_observer,
            stream_stdout_to_terminal=stream_stdout_to_terminal,
            stream_stderr_to_terminal=payload.stream or payload.verbose or not stdout_is_tty,
        )
    )
    duration = time.monotonic() - started

    row = _read_run_row(runtime.repo_root, str(run.run_id))
    status = "failed"
    if row is not None:
        status = row.status
    done_secs = duration
    tokens_total: int | None = None
    if row is not None:
        row_duration = row.duration_secs
        if row_duration is not None:
            done_secs = row_duration
        input_tokens = row.input_tokens
        output_tokens = row.output_tokens
        if input_tokens is not None and output_tokens is not None:
            tokens_total = input_tokens + output_tokens
    _emit_subrun_event(
        {
            "t": "meridian.run.done",
            "id": str(run.run_id),
            "exit": exit_code,
            "secs": done_secs,
            "tok": tokens_total,
            "d": current_depth,
        }
    )

    return RunActionOutput(
        command="run.spawn",
        status=status,
        run_id=str(run.run_id),
        message="Run completed.",
        model=prepared.model,
        harness_id=prepared.harness_id,
        warning=prepared.warning,
        agent=prepared.agent_name,
        skills=prepared.skills,
        reference_files=prepared.reference_files,
        template_vars=prepared.template_vars,
        report_path=prepared.report_path,
        cli_command=prepared.cli_command,
        exit_code=exit_code,
        duration_secs=duration,
    )


async def _execute_run_non_blocking(
    *,
    run_id: RunId,
    repo_root: Path,
    timeout_secs: float | None,
    skills: tuple[str, ...],
    agent_name: str | None,
    mcp_tools: tuple[str, ...],
    permission_config: PermissionConfig,
    allowed_tools: tuple[str, ...] = (),
    cli_permission_override: bool = False,
    budget: Budget | None,
    guardrails: tuple[str, ...],
    secrets: tuple[SecretSpec, ...],
    continue_harness_session_id: str | None,
    continue_fork: bool,
) -> None:
    _ = await _execute_existing_run(
        run_id=run_id,
        repo_root=repo_root,
        timeout_secs=timeout_secs,
        skills=skills,
        agent_name=agent_name,
        mcp_tools=mcp_tools,
        permission_config=permission_config,
        allowed_tools=allowed_tools,
        cli_permission_override=cli_permission_override,
        budget=budget,
        guardrails=guardrails,
        secrets=secrets,
        continue_harness_session_id=continue_harness_session_id,
        continue_fork=continue_fork,
    )


def _track_task(task: asyncio.Task[None]) -> None:
    _BACKGROUND_TASKS.add(task)

    def _cleanup(done: asyncio.Task[None]) -> None:
        try:
            done.result()
        except asyncio.CancelledError:
            pass
        except Exception:
            logger.exception("Background run task failed.")
        finally:
            _BACKGROUND_TASKS.discard(done)

    task.add_done_callback(_cleanup)


def _build_background_worker_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="python -m meridian.lib.ops._run_execute")
    parser.add_argument("--run-id", required=True)
    parser.add_argument("--repo-root", required=True)
    parser.add_argument("--space-id", default=None)
    parser.add_argument("--timeout-secs", type=float, default=None)
    parser.add_argument("--skill", action="append", default=[])
    parser.add_argument("--agent", default=None)
    parser.add_argument("--mcp-tool", action="append", default=[])
    parser.add_argument("--allowed-tool", action="append", default=[])
    parser.add_argument("--permission-tier", required=True)
    parser.add_argument("--unsafe", action="store_true")
    parser.add_argument("--budget-per-run-usd", type=float, default=None)
    parser.add_argument("--budget-per-space-usd", type=float, default=None)
    parser.add_argument("--guardrail", action="append", default=[])
    parser.add_argument("--cli-permission-override", action="store_true")
    parser.add_argument("--continue-harness-session-id", default=None)
    parser.add_argument("--continue-fork", action="store_true")
    return parser


def _background_worker_main(argv: Sequence[str] | None = None) -> int:
    parser = _build_background_worker_parser()
    parsed = parser.parse_args(list(argv) if argv is not None else None)

    budget: Budget | None = None
    if parsed.budget_per_run_usd is not None or parsed.budget_per_space_usd is not None:
        budget = Budget(
            per_run_usd=parsed.budget_per_run_usd,
            per_space_usd=parsed.budget_per_space_usd,
        )
    permission_config = PermissionConfig(
        tier=parse_permission_tier(parsed.permission_tier),
        unsafe=parsed.unsafe,
    )
    secrets = _secrets_from_env()
    allowed_tools = tuple(str(item) for item in parsed.allowed_tool)
    return asyncio.run(
        _execute_existing_run(
            run_id=RunId(parsed.run_id),
            repo_root=Path(parsed.repo_root).expanduser().resolve(),
            space_id_hint=parsed.space_id,
            timeout_secs=parsed.timeout_secs,
            skills=tuple(str(item) for item in parsed.skill),
            agent_name=cast("str | None", parsed.agent),
            mcp_tools=tuple(str(item) for item in parsed.mcp_tool),
            permission_config=permission_config,
            allowed_tools=allowed_tools,
            cli_permission_override=bool(parsed.cli_permission_override),
            budget=budget,
            guardrails=tuple(str(item) for item in parsed.guardrail),
            secrets=secrets,
            continue_harness_session_id=cast("str | None", parsed.continue_harness_session_id),
            continue_fork=bool(parsed.continue_fork),
        )
    )


if __name__ == "__main__":
    raise SystemExit(_background_worker_main())
