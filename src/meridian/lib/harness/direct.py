"""Direct Anthropic adapter with programmatic tool calling."""

# pyright: reportUnknownVariableType=false, reportUnknownArgumentType=false, reportUnknownMemberType=false, reportArgumentType=false

from __future__ import annotations

import asyncio
import json
import os
from typing import TYPE_CHECKING, Any
from urllib import error, request

from meridian.lib.domain import TokenUsage
from meridian.lib.harness.adapter import (
    ArtifactStore,
    HarnessCapabilities,
    PermissionResolver,
    RunParams,
    RunResult,
    StreamEvent,
)
from meridian.lib.ops.codec import (
    coerce_input_payload,
    normalize_optional,
    schema_from_type,
)
from meridian.lib.serialization import to_jsonable
from meridian.lib.types import HarnessId, ModelId, RunId

if TYPE_CHECKING:
    from meridian.lib.ops.registry import OperationSpec

_normalize_optional = normalize_optional


def _usage_from_response(response: dict[str, object]) -> TokenUsage:
    usage = response.get("usage")
    if not isinstance(usage, dict):
        return TokenUsage()
    input_tokens = usage.get("input_tokens", 0)
    output_tokens = usage.get("output_tokens", 0)
    try:
        input_count = int(input_tokens) if input_tokens is not None else 0
    except (TypeError, ValueError):
        input_count = 0
    try:
        output_count = int(output_tokens) if output_tokens is not None else 0
    except (TypeError, ValueError):
        output_count = 0
    total_cost = usage.get("total_cost_usd")
    try:
        parsed_cost = float(total_cost) if total_cost is not None else None
    except (TypeError, ValueError):
        parsed_cost = None
    return TokenUsage(
        input_tokens=input_count,
        output_tokens=output_count,
        total_cost_usd=parsed_cost,
    )


def _extract_text_blocks(content: object) -> str:
    if not isinstance(content, list):
        return ""
    text_parts = [
        str(block.get("text", ""))
        for block in content
        if isinstance(block, dict) and block.get("type") == "text"
    ]
    return "\n".join(part for part in text_parts if part).strip()


class DirectAdapter:
    """HarnessAdapter implementation for Anthropic Messages API mode."""

    @property
    def id(self) -> HarnessId:
        return HarnessId("direct")

    @property
    def capabilities(self) -> HarnessCapabilities:
        return HarnessCapabilities(
            supports_stream_events=False,
            supports_session_resume=False,
            supports_native_skills=False,
            supports_programmatic_tools=True,
        )

    def build_command(self, run: RunParams, perms: PermissionResolver) -> list[str]:
        _ = (run, perms)
        return ["direct"]

    def parse_stream_event(self, line: str) -> StreamEvent | None:
        _ = line
        return None

    def extract_usage(self, artifacts: ArtifactStore, run_id: RunId) -> TokenUsage:
        _ = (artifacts, run_id)
        return TokenUsage()

    def extract_session_id(self, artifacts: ArtifactStore, run_id: RunId) -> str | None:
        _ = (artifacts, run_id)
        return None

    @staticmethod
    def build_tool_definitions() -> list[dict[str, object]]:
        """Generate Anthropic tool definitions from operation registry."""

        # Imported lazily to avoid a startup cycle:
        # harness.registry -> harness.direct -> ops.registry -> ops._runtime -> harness.registry.
        from meridian.lib.ops.registry import get_all_operations

        tools: list[dict[str, object]] = [
            {"type": "code_execution_20260120", "name": "code_execution"}
        ]
        for operation in get_all_operations():
            if operation.cli_only:
                continue
            tools.append(
                {
                    "name": operation.mcp_name,
                    "description": operation.description,
                    "input_schema": schema_from_type(operation.input_type),
                    "allowed_callers": ["code_execution_20260120"],
                }
            )
        return tools

    def _operation_by_mcp_name(self) -> dict[str, OperationSpec[Any, Any]]:
        from meridian.lib.ops.registry import get_all_operations

        return {
            operation.mcp_name: operation
            for operation in get_all_operations()
            if not operation.cli_only
        }

    async def _invoke_operation_tool(self, tool_name: str, raw_input: object) -> object:
        operation_map = self._operation_by_mcp_name()
        operation = operation_map.get(tool_name)
        if operation is None:
            raise KeyError(f"Unknown tool '{tool_name}'")

        payload = coerce_input_payload(operation.input_type, raw_input)
        return await operation.handler(payload)

    def _request_messages(
        self,
        *,
        api_key: str,
        model: str,
        messages: list[dict[str, object]],
        max_tokens: int,
    ) -> dict[str, object]:
        body = {
            "model": model,
            "max_tokens": max_tokens,
            "messages": messages,
            "tools": self.build_tool_definitions(),
        }
        req = request.Request(
            url="https://api.anthropic.com/v1/messages",
            headers={
                "x-api-key": api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json",
            },
            data=json.dumps(body).encode("utf-8"),
            method="POST",
        )
        try:
            with request.urlopen(req, timeout=60) as response:
                raw = response.read().decode("utf-8")
        except error.HTTPError as exc:  # pragma: no cover - network/credential dependent.
            details = exc.read().decode("utf-8", errors="replace")
            raise RuntimeError(f"Anthropic API error {exc.code}: {details}") from exc
        except error.URLError as exc:  # pragma: no cover - network dependent.
            raise RuntimeError(f"Anthropic API request failed: {exc.reason}") from exc

        payload = json.loads(raw)
        if not isinstance(payload, dict):
            raise RuntimeError("Anthropic API returned a non-object JSON payload.")
        return payload

    async def execute(
        self,
        *,
        prompt: str,
        model: ModelId,
        api_key: str | None = None,
        max_tokens: int = 2048,
        max_tool_round_trips: int = 8,
    ) -> RunResult:
        """Execute one prompt via Anthropic Messages API with tool-calling support."""

        key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if not key:
            raise ValueError("ANTHROPIC_API_KEY is required for direct mode.")

        messages: list[dict[str, object]] = [{"role": "user", "content": prompt}]
        final_usage = TokenUsage()
        final_response: dict[str, object] | None = None

        for _ in range(max_tool_round_trips):
            response = await asyncio.to_thread(
                self._request_messages,
                api_key=key,
                model=str(model),
                messages=messages,
                max_tokens=max_tokens,
            )
            final_response = response
            final_usage = _usage_from_response(response)

            content = response.get("content", [])
            if not isinstance(content, list):
                content = []

            messages.append({"role": "assistant", "content": content})
            tool_uses = [
                block
                for block in content
                if isinstance(block, dict) and block.get("type") == "tool_use"
            ]

            if not tool_uses:
                output = _extract_text_blocks(content)
                return RunResult(
                    status="succeeded",
                    output=output,
                    usage=final_usage,
                    raw_response=final_response,
                )

            tool_results: list[dict[str, object]] = []
            for block in tool_uses:
                tool_use_id = str(block.get("id", ""))
                tool_name = str(block.get("name", ""))
                tool_input = block.get("input")
                result = await self._invoke_operation_tool(tool_name, tool_input)
                tool_results.append(
                    {
                        "type": "tool_result",
                        "tool_use_id": tool_use_id,
                        "content": json.dumps(to_jsonable(result), sort_keys=True),
                    }
                )

            messages.append({"role": "user", "content": tool_results})

        return RunResult(
            status="failed",
            output="Direct adapter exceeded tool-calling round-trip limit.",
            usage=final_usage,
            raw_response=final_response,
        )
